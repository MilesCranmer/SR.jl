<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types · SymbolicRegression.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://astroautomata.com/SymbolicRegression.jl/stable/types/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index_base/"><img src="../assets/logo.svg" alt="SymbolicRegression.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index_base/">SymbolicRegression.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index_base/">Contents</a></li><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../losses/">Losses</a></li><li class="is-active"><a class="tocitem" href>Types</a><ul class="internal"><li><a class="tocitem" href="#Equations"><span>Equations</span></a></li><li><a class="tocitem" href="#Expressions"><span>Expressions</span></a></li><li><a class="tocitem" href="#Parametric-Expressions"><span>Parametric Expressions</span></a></li><li><a class="tocitem" href="#Custom-Expressions"><span>Custom Expressions</span></a></li><li><a class="tocitem" href="#Population"><span>Population</span></a></li><li><a class="tocitem" href="#Population-members"><span>Population members</span></a></li><li><a class="tocitem" href="#Hall-of-Fame"><span>Hall of Fame</span></a></li><li><a class="tocitem" href="#Dataset"><span>Dataset</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/master/docs/src/types.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h1><h2 id="Equations"><a class="docs-heading-anchor" href="#Equations">Equations</a><a id="Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Equations" title="Permalink"></a></h2><p>Equations are specified as binary trees with the <code>Node</code> type, defined as follows.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.NodeModule.Node" href="#DynamicExpressions.NodeModule.Node"><code>DynamicExpressions.NodeModule.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Node{T} &lt;: AbstractExpressionNode{T}</code></pre><p>Node defines a symbolic expression stored in a binary tree. A single <code>Node</code> instance is one &quot;node&quot; of this tree, and has references to its children. By tracing through the children nodes, you can evaluate or print a given expression.</p><p><strong>Fields</strong></p><ul><li><code>degree::UInt8</code>: Degree of the node. 0 for constants, 1 for   unary operators, 2 for binary operators.</li><li><code>constant::Bool</code>: Whether the node is a constant.</li><li><code>val::T</code>: Value of the node. If <code>degree==0</code>, and <code>constant==true</code>,   this is the value of the constant. It has a type specified by the   overall type of the <code>Node</code> (e.g., <code>Float64</code>).</li><li><code>feature::UInt16</code>: Index of the feature to use in the   case of a feature node. Only used if <code>degree==0</code> and <code>constant==false</code>.    Only defined if <code>degree == 0 &amp;&amp; constant == false</code>.</li><li><code>op::UInt8</code>: If <code>degree==1</code>, this is the index of the operator   in <code>operators.unaops</code>. If <code>degree==2</code>, this is the index of the   operator in <code>operators.binops</code>. In other words, this is an enum   of the operators, and is dependent on the specific <code>OperatorEnum</code>   object. Only defined if <code>degree &gt;= 1</code></li><li><code>l::Node{T}</code>: Left child of the node. Only defined if <code>degree &gt;= 1</code>.   Same type as the parent node.</li><li><code>r::Node{T}</code>: Right child of the node. Only defined if <code>degree == 2</code>.   Same type as the parent node. This is to be passed as the right   argument to the binary operator.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">Node([T]; val=nothing, feature=nothing, op=nothing, l=nothing, r=nothing, children=nothing, allocator=default_allocator)
Node{T}(; val=nothing, feature=nothing, op=nothing, l=nothing, r=nothing, children=nothing, allocator=default_allocator)</code></pre><p>Create a new node in an expression tree. If <code>T</code> is not specified in either the type or the first argument, it will be inferred from the value of <code>val</code> passed or <code>l</code> and/or <code>r</code>. If it cannot be inferred from these, it will default to <code>Float32</code>.</p><p>The <code>children</code> keyword can be used instead of <code>l</code> and <code>r</code> and should be a tuple of children. This is to permit the use of splatting in constructors.</p><p>You may also construct nodes via the convenience operators generated by creating an <code>OperatorEnum</code>.</p><p>You may also choose to specify a default memory allocator for the node other than simply <code>Node{T}()</code> in the <code>allocator</code> keyword argument.</p></div></section></article><p>When you create an <code>Options</code> object, the operators passed are also re-defined for <code>Node</code> types. This allows you use, e.g., <code>t=Node(; feature=1) * 3f0</code> to create a tree, so long as <code>*</code> was specified as a binary operator. This works automatically for operators defined in <code>Base</code>, although you can also get this to work for user-defined operators by using <code>@extend_operators</code>:</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.InterfaceDynamicExpressionsModule.@extend_operators-Tuple{Any}" href="#SymbolicRegression.InterfaceDynamicExpressionsModule.@extend_operators-Tuple{Any}"><code>SymbolicRegression.InterfaceDynamicExpressionsModule.@extend_operators</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@extend_operators options</code></pre><p>Extends all operators defined in this options object to work on the <code>AbstractExpressionNode</code> type. While by default this is already done for operators defined in <code>Base</code> when you create an options and pass <code>define_helper_functions=true</code>, this does not apply to the user-defined operators. Thus, to do so, you must apply this macro to the operator enum in the same module you have the operators defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/6e3cdf529ed142a1711736047d655af5d54d62dd/src/InterfaceDynamicExpressions.jl#L308-L317">source</a></section></article><p>When using these node constructors, types will automatically be promoted. You can convert the type of a node using <code>convert</code>:</p><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{T2}, Tuple{T1}, Tuple{Type{Node{T1}}, Node{T2}}} where {T1, T2}" href="#Base.convert-Union{Tuple{T2}, Tuple{T1}, Tuple{Type{Node{T1}}, Node{T2}}} where {T1, T2}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convert(::Type{&lt;:AbstractExpressionNode{T1}}, n::AbstractExpressionNode{T2}) where {T1,T2}</code></pre><p>Convert a <code>AbstractExpressionNode{T2}</code> to a <code>AbstractExpressionNode{T1}</code>. This will recursively convert all children nodes to <code>AbstractExpressionNode{T1}</code>, using <code>convert(T1, tree.val)</code> at constant nodes.</p><p><strong>Arguments</strong></p><ul><li><code>::Type{AbstractExpressionNode{T1}}</code>: Type to convert to.</li><li><code>tree::AbstractExpressionNode{T2}</code>: AbstractExpressionNode to convert.</li></ul></div></section></article><p>You can set a <code>tree</code> (in-place) with <code>set_node!</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.NodeModule.set_node!" href="#DynamicExpressions.NodeModule.set_node!"><code>DynamicExpressions.NodeModule.set_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_node!(tree::AbstractExpressionNode{T}, new_tree::AbstractExpressionNode{T}) where {T}</code></pre><p>Set every field of <code>tree</code> equal to the corresponding field of <code>new_tree</code>.</p></div></section></article><p>You can create a copy of a node with <code>copy_node</code>:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.NodeModule.copy_node-Tuple{Node}" href="#DynamicExpressions.NodeModule.copy_node-Tuple{Node}"><code>DynamicExpressions.NodeModule.copy_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy_node(tree::AbstractExpressionNode; break_sharing::Val{BS}=Val(false)) where {BS}</code></pre><p>Copy a node, recursively copying all children nodes. This is more efficient than the built-in copy.</p><p>If <code>break_sharing</code> is set to <code>Val(true)</code>, sharing in a tree will be ignored.</p></div></section></article><h2 id="Expressions"><a class="docs-heading-anchor" href="#Expressions">Expressions</a><a id="Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions" title="Permalink"></a></h2><p>Expressions are represented using the <code>Expression</code> type, which combines the raw <code>Node</code> type with an <code>OperatorEnum</code>.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.ExpressionModule.Expression" href="#DynamicExpressions.ExpressionModule.Expression"><code>DynamicExpressions.ExpressionModule.Expression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Expression{T, N, D} &lt;: AbstractExpression{T, N}</code></pre><p>(Experimental) Defines a high-level, user-facing, expression type that encapsulates an expression tree (like <code>Node</code>) along with associated metadata for evaluation and rendering.</p><p><strong>Fields</strong></p><ul><li><code>tree::N</code>: The root node of the raw expression tree.</li><li><code>metadata::Metadata{D}</code>: A named tuple of settings for the expression,   such as the operators and variable names.</li></ul><p><strong>Constructors</strong></p><ul><li><code>Expression(tree::AbstractExpressionNode, metadata::NamedTuple)</code>: Construct from the fields</li><li><code>@parse_expression(expr, operators=operators, variable_names=variable_names, node_type=Node)</code>: Parse a Julia expression with a given context and create an Expression object.</li></ul><p><strong>Usage</strong></p><p>This type is intended for end-users to interact with and manipulate expressions at a high level, abstracting away the complexities of the underlying expression tree operations.</p></div></section></article><p>These types allow you to define and manipulate expressions with a clear separation between the structure and the operators used.</p><h2 id="Parametric-Expressions"><a class="docs-heading-anchor" href="#Parametric-Expressions">Parametric Expressions</a><a id="Parametric-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-Expressions" title="Permalink"></a></h2><p>Parametric expressions are a type of expression that includes parameters which can be optimized during the search.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.ParametricExpressionModule.ParametricExpression" href="#DynamicExpressions.ParametricExpressionModule.ParametricExpression"><code>DynamicExpressions.ParametricExpressionModule.ParametricExpression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParametricExpression{T,N&lt;:ParametricNode{T},D&lt;:NamedTuple} &lt;: AbstractExpression{T,N}</code></pre><p>(Experimental) An expression to store parameters for a tree</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.ParametricExpressionModule.ParametricNode" href="#DynamicExpressions.ParametricExpressionModule.ParametricNode"><code>DynamicExpressions.ParametricExpressionModule.ParametricNode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A type of expression node that also stores a parameter index</p></div></section></article><p>These types allow you to define expressions with parameters that can be tuned to fit the data better. You can specify the maximum number of parameters using the <code>expression_options</code> argument in <code>SRRegressor</code>.</p><h2 id="Custom-Expressions"><a class="docs-heading-anchor" href="#Custom-Expressions">Custom Expressions</a><a id="Custom-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Expressions" title="Permalink"></a></h2><p>You can create your own expression types by defining a new type that extends <code>AbstractExpression</code>.</p><article class="docstring"><header><a class="docstring-binding" id="DynamicExpressions.ExpressionModule.AbstractExpression" href="#DynamicExpressions.ExpressionModule.AbstractExpression"><code>DynamicExpressions.ExpressionModule.AbstractExpression</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractExpression{T,N}</code></pre><p>(Experimental) Abstract type for user-facing expression types, which contain both the raw expression tree operating on a value type of <code>T</code>, as well as associated metadata to evaluate and render the expression.</p><p>See <a href="@ref DynamicExpressions.InterfacesModule.ExpressionInterface"><code>ExpressionInterface</code></a> for a full description of the interface implementation, as well as tests to verify correctness.</p><p>If you wish to use <code>@parse_expression</code>, you can also customize the parsing behavior with</p><ul><li><code>parse_leaf</code></li></ul></div></section></article><p>The interface is fairly flexible, and permits you define specific functional forms, extra parameters, etc. See the documentation of DynamicExpressions.jl for more details on what methods you need to implement. Then, for SymbolicRegression.jl, you would pass <code>expression_type</code> to the <code>Options</code> constructor, as well as any <code>expression_options</code> you need (as a <code>NamedTuple</code>).</p><p>If needed, you may need to overload <code>SymbolicRegression.ExpressionBuilder.extra_init_params</code> in case your expression needs additional parameters. See the method for <code>ParametricExpression</code> as an example.</p><h2 id="Population"><a class="docs-heading-anchor" href="#Population">Population</a><a id="Population-1"></a><a class="docs-heading-anchor-permalink" href="#Population" title="Permalink"></a></h2><p>Groups of equations are given as a population, which is an array of trees tagged with score, loss, and birthdate–-these values are given in the <code>PopMember</code>.</p><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.PopulationModule.Population" href="#SymbolicRegression.PopulationModule.Population"><code>SymbolicRegression.PopulationModule.Population</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Population(pop::Array{PopMember{T,L}, 1})</code></pre><p>Create population from list of PopMembers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/6e3cdf529ed142a1711736047d655af5d54d62dd/src/Population.jl#L19-L23">source</a></section><section><div><pre><code class="nohighlight hljs">Population(dataset::Dataset{T,L};
           population_size, nlength::Int=3, options::Options,
           nfeatures::Int)</code></pre><p>Create random population and score them on the dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/6e3cdf529ed142a1711736047d655af5d54d62dd/src/Population.jl#L28-L34">source</a></section><section><div><pre><code class="nohighlight hljs">Population(X::AbstractMatrix{T}, y::AbstractVector{T};
           population_size, nlength::Int=3,
           options::Options, nfeatures::Int,
           loss_type::Type=Nothing)</code></pre><p>Create random population and score them on the dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/6e3cdf529ed142a1711736047d655af5d54d62dd/src/Population.jl#L62-L69">source</a></section></article><h2 id="Population-members"><a class="docs-heading-anchor" href="#Population-members">Population members</a><a id="Population-members-1"></a><a class="docs-heading-anchor-permalink" href="#Population-members" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.PopMemberModule.PopMember" href="#SymbolicRegression.PopMemberModule.PopMember"><code>SymbolicRegression.PopMemberModule.PopMember</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PopMember(t::AbstractExpression{T}, score::L, loss::L)</code></pre><p>Create a population member with a birth date at the current time. The type of the <code>Node</code> may be different from the type of the score and loss.</p><p><strong>Arguments</strong></p><ul><li><code>t::AbstractExpression{T}</code>: The tree for the population member.</li><li><code>score::L</code>: The score (normalized to a baseline, and offset by a complexity penalty)</li><li><code>loss::L</code>: The raw loss to assign.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/6e3cdf529ed142a1711736047d655af5d54d62dd/src/PopMember.jl#L47-L59">source</a></section><section><div><pre><code class="nohighlight hljs">PopMember(
    dataset::Dataset{T,L},
    t::AbstractExpression{T},
    options::Options
)</code></pre><p>Create a population member with a birth date at the current time. Automatically compute the score for this tree.</p><p><strong>Arguments</strong></p><ul><li><code>dataset::Dataset{T,L}</code>: The dataset to evaluate the tree on.</li><li><code>t::AbstractExpression{T}</code>: The tree for the population member.</li><li><code>options::Options</code>: What options to use.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/6e3cdf529ed142a1711736047d655af5d54d62dd/src/PopMember.jl#L92-L107">source</a></section></article><h2 id="Hall-of-Fame"><a class="docs-heading-anchor" href="#Hall-of-Fame">Hall of Fame</a><a id="Hall-of-Fame-1"></a><a class="docs-heading-anchor-permalink" href="#Hall-of-Fame" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.HallOfFameModule.HallOfFame" href="#SymbolicRegression.HallOfFameModule.HallOfFame"><code>SymbolicRegression.HallOfFameModule.HallOfFame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HallOfFame{T&lt;:DATA_TYPE,L&lt;:LOSS_TYPE}</code></pre><p>List of the best members seen all time in <code>.members</code>, with <code>.members[c]</code> being the best member seen at complexity c. Including only the members which actually have been set, you can run <code>.members[exists]</code>.</p><p><strong>Fields</strong></p><ul><li><code>members::Array{PopMember{T,L},1}</code>: List of the best members seen all time.   These are ordered by complexity, with <code>.members[1]</code> the member with complexity 1.</li><li><code>exists::Array{Bool,1}</code>: Whether the member at the given complexity has been set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/6e3cdf529ed142a1711736047d655af5d54d62dd/src/HallOfFame.jl#L12-L24">source</a></section></article><h2 id="Dataset"><a class="docs-heading-anchor" href="#Dataset">Dataset</a><a id="Dataset-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.CoreModule.DatasetModule.Dataset" href="#SymbolicRegression.CoreModule.DatasetModule.Dataset"><code>SymbolicRegression.CoreModule.DatasetModule.Dataset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Dataset{T&lt;:DATA_TYPE,L&lt;:LOSS_TYPE}</code></pre><p><strong>Fields</strong></p><ul><li><code>X::AbstractMatrix{T}</code>: The input features, with shape <code>(nfeatures, n)</code>.</li><li><code>y::AbstractVector{T}</code>: The desired output values, with shape <code>(n,)</code>.</li><li><code>index::Int</code>: The index of the output feature corresponding to this   dataset, if any.</li><li><code>n::Int</code>: The number of samples.</li><li><code>nfeatures::Int</code>: The number of features.</li><li><code>weighted::Bool</code>: Whether the dataset is non-uniformly weighted.</li><li><code>weights::Union{AbstractVector{T},Nothing}</code>: If the dataset is weighted,   these specify the per-sample weight (with shape <code>(n,)</code>).</li><li><code>extra::NamedTuple</code>: Extra information to pass to a custom evaluation   function. Since this is an arbitrary named tuple, you could pass   any sort of dataset you wish to here.</li><li><code>avg_y</code>: The average value of <code>y</code> (weighted, if <code>weights</code> are passed).</li><li><code>use_baseline</code>: Whether to use a baseline loss. This will be set to <code>false</code>   if the baseline loss is calculated to be <code>Inf</code>.</li><li><code>baseline_loss</code>: The loss of a constant function which predicts the average   value of <code>y</code>. This is loss-dependent and should be updated with   <code>update_baseline_loss!</code>.</li><li><code>variable_names::Array{String,1}</code>: The names of the features,   with shape <code>(nfeatures,)</code>.</li><li><code>display_variable_names::Array{String,1}</code>: A version of <code>variable_names</code>   but for printing to the terminal (e.g., with unicode versions).</li><li><code>y_variable_name::String</code>: The name of the output variable.</li><li><code>X_units</code>: Unit information of <code>X</code>. When used, this is a vector   of <code>DynamicQuantities.Quantity{&lt;:Any,&lt;:Dimensions}</code> with shape <code>(nfeatures,)</code>.</li><li><code>y_units</code>: Unit information of <code>y</code>. When used, this is a single   <code>DynamicQuantities.Quantity{&lt;:Any,&lt;:Dimensions}</code>.</li><li><code>X_sym_units</code>: Unit information of <code>X</code>. When used, this is a vector   of <code>DynamicQuantities.Quantity{&lt;:Any,&lt;:SymbolicDimensions}</code> with shape <code>(nfeatures,)</code>.</li><li><code>y_sym_units</code>: Unit information of <code>y</code>. When used, this is a single   <code>DynamicQuantities.Quantity{&lt;:Any,&lt;:SymbolicDimensions}</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/6e3cdf529ed142a1711736047d655af5d54d62dd/src/Dataset.jl#L11-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymbolicRegression.LossFunctionsModule.update_baseline_loss!" href="#SymbolicRegression.LossFunctionsModule.update_baseline_loss!"><code>SymbolicRegression.LossFunctionsModule.update_baseline_loss!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_baseline_loss!(dataset::Dataset{T,L}, options::Options) where {T&lt;:DATA_TYPE,L&lt;:LOSS_TYPE}</code></pre><p>Update the baseline loss of the dataset using the loss function specified in <code>options</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MilesCranmer/SymbolicRegression.jl/blob/6e3cdf529ed142a1711736047d655af5d54d62dd/src/LossFunctions.jl#L204-L208">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../losses/">« Losses</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 7 October 2024 17:53">Monday 7 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
